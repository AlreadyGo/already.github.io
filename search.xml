<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线程池原理</title>
    <url>/2019/10/10/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4java%E6%89%8B%E5%86%8C%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="阿里巴巴java手册中关于线程的说明"><a href="#阿里巴巴java手册中关于线程的说明" class="headerlink" title="阿里巴巴java手册中关于线程的说明"></a>阿里巴巴java手册中关于线程的说明</h2><p>1.【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯<br>正例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">TimerTaskThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">super</span>.setName(<span class="string">"TimerTaskThread"</span>);</span><br><span class="line">... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明:使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决 资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或 者“过度切换”的问题。<br>3.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明:Executors 返回的线程池对象的弊端如下:</p>
<ul>
<li><p>FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p>CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
</li>
</ul>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="参数及工作原理"><a href="#参数及工作原理" class="headerlink" title="参数及工作原理"></a>参数及工作原理</h3><p>首先是创建线程的 api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>这几个核心参数的作用：</p>
<ul>
<li><code>corePoolSize</code> 为线程池的基本大小。</li>
<li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
<li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
<li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的拒绝策略。</li>
</ul>
<p>问题：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())</span><br></pre></td></tr></table></figure></p>
<p>maximumPoolSize=20会不会起作用？</p>
<p>提交任务</p>
<ol>
<li>当前线程数量小于 coreSize 时创建一个新的线程运行,即使有空闲线程。</li>
<li>当前线程数量大于 coreSize并且小于maximumPoolSize，会写入到队列中，只有当队列写满时才会继续创建新的线程</li>
<li>如果coreSize等于maximumPoolSize，那么创建的是一个固定大小的线程池</li>
<li>默认初始化的时候线程池中是没有线程的，只有当有新的任务提交的时候才会创建新线程，但是可以重写prestartCoreThread或者prestartAllCoreThreads方法，使得构造线程池的时候预先启动线程</li>
<li>新线程是通过ThreadFactory创建的</li>
<li>如果线程池里线程数超过corePoolSize，那么空闲时间超过keepAliveTime的线程会被终止掉，默认只会终止maximumPoolSize-coreSize那部分线程，allowCoreThreadTimeOut(true)可以使超时策略对核心线程同样起作用</li>
<li><p>当线程数超过maximumPoolSize的时候，会采用拒绝策略，jdk提供了几种通用的策略，默认策略，抛出RejectedExecutionException</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default rejected execution handler</span><br><span class="line"> */</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler =</span><br><span class="line">    new AbortPolicy();</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个任务执行前后的钩子函数beforeExecute和afterExecute</p>
</li>
</ol>
<p>具体看代码</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul>
<li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
<li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>
<h3 id="配置线程数"><a href="#配置线程数" class="headerlink" title="配置线程数"></a>配置线程数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cupNum = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>
<p>一般线程数配置核数的1-2倍</p>
<h2 id="SpringBoot-使用线程池"><a href="#SpringBoot-使用线程池" class="headerlink" title="SpringBoot 使用线程池"></a>SpringBoot 使用线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费队列线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(value = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildConsumerQueueThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">"consumer-queue-thread-%d"</span>).build();</span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>),namedThreadFactory,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> pool ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line"><span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//消费队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        consumerQueueThreadPool.execute(<span class="keyword">new</span> ConsumerQueueThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>electron实现简单的爬虫客户端</title>
    <url>/2018/01/28/electron%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h3 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h3><p><a href="https://github.com/AlreadyGo/crawler-client/releases" target="_blank" rel="noopener">下载win客户端/绿色免安装</a></p>
<h3 id="解压客户端压缩包"><a href="#解压客户端压缩包" class="headerlink" title="解压客户端压缩包"></a>解压客户端压缩包</h3><h3 id="双击crawler-devTools-exe"><a href="#双击crawler-devTools-exe" class="headerlink" title="双击crawler-devTools.exe"></a>双击crawler-devTools.exe</h3><p><img src="/images/crawler/crawler-devTools.png" alt="crawler-devTools.png"></p>
<h3 id="在控制台执行代码"><a href="#在控制台执行代码" class="headerlink" title="在控制台执行代码"></a>在控制台执行代码</h3><ul>
<li>$toggleCrawlerLog(): 打印log</li>
<li>showDevTool(): 调出控制台<br><img src="/images/crawler/console.png" alt="console.png"><h3 id="爬取微博明星分类下前100页数据"><a href="#爬取微博明星分类下前100页数据" class="headerlink" title="爬取微博明星分类下前100页数据"></a>爬取微博明星分类下前100页数据</h3><a href="https://d.weibo.com/1087030002_2975_1003_0#" target="_blank" rel="noopener">微博链接</a><br><img src="/images/crawler/微博列表页.png" alt="微博列表页.png"><br>在控制台执行以下代码:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var config = [&#123;</span><br><span class="line">    type: &quot;waitFor&quot;,</span><br><span class="line">    selector: &quot;body .WB_miniblog .PCD_followlist&quot;,</span><br><span class="line">    timeout: 30</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    type: &apos;script&apos;,</span><br><span class="line">    async: true,</span><br><span class="line">    timeout: 60,</span><br><span class="line">    func: function(args, target, callback) &#123;</span><br><span class="line">        new Promise(function(f) &#123;</span><br><span class="line">            if (window.jQuery &amp;&amp; window.$) return f(0);</span><br><span class="line">            var script = document.createElement(&quot;script&quot;);</span><br><span class="line">            script.type = &quot;text/javascript&quot;;</span><br><span class="line">            script.onload = f;</span><br><span class="line">            script.src = &quot;//cdn.bootcss.com/jquery/2.1.4/jquery.min.js&quot;;</span><br><span class="line">            document.body.appendChild(script);</span><br><span class="line">        &#125;).then(() =&gt; &#123;</span><br><span class="line">            var html = $(&apos;body .WB_miniblog&apos;);</span><br><span class="line"></span><br><span class="line">            function transform(t) &#123;</span><br><span class="line">                var r = [];</span><br><span class="line">                t.find(&apos;dd.mod_info&apos;).each((i, v) =&gt; &#123;</span><br><span class="line">                    var o = &#123;&#125;,</span><br><span class="line">                        $t = $(v);</span><br><span class="line">                    o.name = $t.find(&apos;.info_name a strong&apos;).text();</span><br><span class="line">                    o.url = $t.find(&apos;.info_name a&apos;).attr(&apos;href&apos;);</span><br><span class="line">                    o.connect = $t.find(&apos;.info_connect span:eq(0) .count&apos;).text();</span><br><span class="line">                    o.fans = $t.find(&apos;.info_connect span:eq(1) .count&apos;).text();</span><br><span class="line">                    o.weibo = $t.find(&apos;.info_connect span:eq(2) .count&apos;).text();</span><br><span class="line">                    o.address = $t.find(&apos;.info_add span&apos;).text();</span><br><span class="line">                    o.intro = $t.find(&apos;.info_intro span&apos;).text();</span><br><span class="line">                    r.push(o)</span><br><span class="line">                &#125;);</span><br><span class="line">                return r;</span><br><span class="line">            &#125;</span><br><span class="line">            target.data = transform(html);</span><br><span class="line">            target.cat = args.cat;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let pool = new WebPagePool(5);</span><br><span class="line"></span><br><span class="line">let callback = data =&gt; &#123;</span><br><span class="line">    if (!result[data.cat])result[data.cat]=[];</span><br><span class="line">    result[data.cat].push(...data.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">let cats =</span><br><span class="line">    [&#123;&quot;url&quot;:&quot;https://d.weibo.com/1087030002_2975_1003_0&quot;,&quot;cat&quot;:&quot;明星&quot;,&quot;total&quot;:100&#125;];</span><br><span class="line"></span><br><span class="line">cats.forEach((cat)=&gt;&#123;</span><br><span class="line">    let len = cat.total;</span><br><span class="line">    for(var i=1;i&lt;len+1;i++)&#123;</span><br><span class="line">        pool.submit(config,Object.assign(&#123;&#125;,cat,&#123;url:`$&#123;cat.url&#125;?page=$&#123;i&#125;`&#125;),callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><ul>
<li>均使用jq(sizzle)选择器</li>
<li>config: 对象数组, executor会按顺序执行爬取动作</li>
<li>waitFor: 等待$(‘body .WB_miniblog .PCD_followlist’)元素出现,超时时间30s</li>
<li>script: 在页面上执行异步脚本, args(参数,执行任务中传入,其中{url}表示需要请求的链接), target(执行结果,最终会返回), callback(脚本执行完必须调用callback方法)</li>
<li>结果: 本例的结果均放入result变量中<br><img src="/images/crawler/运行中的结果.png" alt="运行中的结果.png"></li>
<li>WebPagePool: 页面池, 打开多个页面异步执行爬取任务<br>let pool = new WebPagePool(5); 创建一个有五个页面的页面池<br><img src="/images/crawler/electron的webview.png" alt="electron的webview.png"></li>
<li>WebPagePool常用方法<br>pool.submit(config,args,callback): config爬取配置,args爬取参数,callback回调方法(callback的参数就是script中的target)<br>pool.queue: 等待执行的任务<br>pool.failQueue: 失败的任务<br>pool.failBack(): 失败任务全部重试<br>pool.isOver(): 页面池的任务是否结束<br>pool.close(): 销毁页面池<br><img src="/images/crawler/pool-methods.png" alt="pool-methods.png"></li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>electron</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch之cardinality浅析</title>
    <url>/2017/11/19/elasticsearch%E4%B9%8Bcardinality%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大数据时代,类似sum求和或者avg平均值的操作还是相对容易,而比如类似算网站uv或者<br>找出网站访问最频繁访客会比较困难,es中提供了一种cardinality聚合来解决这类问题.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET &quot;http://localhost:9200/_search&quot; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;monthly&quot;: &#123;</span><br><span class="line">            &quot;date_histogram&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;timestamp&quot;,</span><br><span class="line">                &quot;interval&quot;: &quot;month&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;visitor_count&quot;: &#123;</span><br><span class="line">                    &quot;cardinality&quot;: &#123;</span><br><span class="line">                        &quot;field&quot;: &quot;ip_address&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="基数估算算法"><a href="#基数估算算法" class="headerlink" title="基数估算算法"></a>基数估算算法</h2><p>数据集小的时候,当然可以使用hashset,但是数据量过大的时候,内存使用就会很致命.传统的基数计数实现有两种,基于B树和基于bitmap,B树在问题在于不能高效合并,bitmap问题在于bitmap的长度与集合中元素个数无关，而是与基数的上限有关,例如“00100110”表示集合 {2，5，6}。bitmap中1的数量就是这个集合的基数,<br>这两种方法在大数据场景下都会有内存问题.<br>幸运的是,还有其他的基数计数算法.其中比较有名的就是linear counting和loglog counting,HyperLogLog</p>
<h3 id="lc算法"><a href="#lc算法" class="headerlink" title="lc算法"></a>lc算法</h3><p>LC的基本思路是：设有一哈希函数H，其哈希结果空间有m个值（最小值0，最大值m-1），并且哈希结果服从均匀分布。使用一个长度为m的bitmap，每个bit为一个桶，均初始化为0，设一个集合的基数为n，此集合所有元素通过H哈希到bitmap中，如果某一个元素被哈希到第k个比特并且第k个比特为0，则将其置为1。当集合所有元素哈希完成后，设bitmap中还有u个bit为0。则：<br>n^=−mlogumn^=−mlogum<br>为n的一个估计，且为最大似然估计（MLE）。<br><img src="/images/lc.png" alt="lc"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LinearCounter &#123;</span><br><span class="line">    BitSet mask = new BitSet(m) // m is a design parameter</span><br><span class="line"> </span><br><span class="line">    void add(value) &#123;</span><br><span class="line">        int position = hash(value) // map the value to the range 0..m</span><br><span class="line">        mask.set(position) // sets a bit in the mask to 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>精度要求越高，则bitmap的长度越大。随着m和n的增大，m大约为n的十分之一。因此LC所需要的空间只有传统的bitmap直接映射方法的1/10.</p>
<h3 id="llc算法"><a href="#llc算法" class="headerlink" title="llc算法"></a>llc算法</h3><p>LLC的空间复杂度仅有O(log2(log2(Nmax)))，使得通过KB级内存估计数亿级别的基数成为可能.<br>例如,假设基数的上限为1亿，原始bitmap方法需要12.5M内存，而LogLog Counting只需不到1K内存（640字节）就可以在标准误差不超过4%的精度下对基数进行估计,因此目前在处理大数据的基数计算问题时，所采用算法基本为LLC或其几个变种<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LogLogCounter &#123;</span><br><span class="line">    int H           // H is a design parameter</span><br><span class="line">    int m = 2^k         // k is a design parameter</span><br><span class="line">    etype[] estimators = new etype[m] // etype is a design parameter</span><br><span class="line"> </span><br><span class="line">    void add(value) &#123;</span><br><span class="line">        hashedValue = hash(value)</span><br><span class="line">        bucket = getBits(hashedValue, 0, k)</span><br><span class="line">        estimators[bucket] = max(</span><br><span class="line">            estimators[bucket],</span><br><span class="line">            rank( getBits(hashedValue, k, H) )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getBits(value, int start, int end)</span><br><span class="line">    rank(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>它们都是基于hash而非数值</li>
<li>它们返回的结果都是近似值</li>
<li>linear counting作为一个早期的算法,空间复杂度并不优秀,在基数大的时候结果会很不准,很少单独使用</li>
<li>相比LC其最大的优势就是内存使用极少。不过LLC也有自己的问题，就是当n不是特别大时，其估计误差过大</li>
<li>HyperLogLog是一种结合LC和LLC的一种改进算法,可以用相对固定的内存估算任意大集合的计数</li>
</ul>
<p>es中主要参考了google出品的HyperLogLog++算法,略有改动,在一定条件下,lc算法会升级到hll算法,详见es源码中org.elasticsearch.search.aggregations.metrics.cardinality.HyperLogLogPlusPlus类.</p>
<h2 id="精度和内存"><a href="#精度和内存" class="headerlink" title="精度和内存"></a>精度和内存</h2><p>为了节约内存,精度方面会有所牺牲.es提供了一个可配置的precision_threshold参数,来配置cardinality的精度,<br>threshold参数的取值范围在0-4w,默认为3000,<br>精度和内存的使用都与这个参数相关,假设precision_threshold为N,那么你期望每个分片每个聚合桶上的内存大约是8*N字节.<br>源码中可以发现,precision_threshold会转化成precision精度,precision的取值范围在4-18,默认为14,<br>也就是对应precision_threshold=3000<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Compute the required precision so that &lt;code&gt;count&lt;/code&gt; distinct entries</span><br><span class="line"> * would be counted with linear counting.</span><br><span class="line"> */</span><br><span class="line">public static int precisionFromThreshold(long count) &#123;</span><br><span class="line">    final long hashTableEntries = (long) Math.ceil(count / MAX_LOAD_FACTOR);</span><br><span class="line">    int precision = PackedInts.bitsRequired(hashTableEntries * Integer.BYTES);</span><br><span class="line">    precision = Math.max(precision, MIN_PRECISION);</span><br><span class="line">    precision = Math.min(precision, MAX_PRECISION);</span><br><span class="line">    return precision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个<em>相对精度丢失图</em>:<br><img src="/images/cardinality_error.png" alt="cardinality error"><br>对于三种阈值,在不同基数下的精度丢失,可以发现就算阈值低至100,在百千万级别的数据量下.精度丢失也在5%以下</p>
]]></content>
      <tags>
        <tag>elasticsearch</tag>
        <tag>cardinality</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch.yml中重要的配置检查</title>
    <url>/2017/11/13/elasticsearch-yml%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>启动集群最小的配置</p>
<h3 id="path-data-和-path-logs"><a href="#path-data-和-path-logs" class="headerlink" title="path.data 和 path.logs"></a>path.data 和 path.logs</h3><p>数据和日志文件路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path:</span><br><span class="line">  logs: /var/log/elasticsearch</span><br><span class="line">  data: /var/data/elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>设置多个路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path:</span><br><span class="line">  data:</span><br><span class="line">    - /mnt/elasticsearch_1</span><br><span class="line">    - /mnt/elasticsearch_2</span><br><span class="line">    - /mnt/elasticsearch_3</span><br></pre></td></tr></table></figure></p>
<h3 id="cluster-name"><a href="#cluster-name" class="headerlink" title="cluster.name"></a>cluster.name</h3><p>集群名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.name: logging-prod</span><br></pre></td></tr></table></figure></p>
<h3 id="node-name"><a href="#node-name" class="headerlink" title="node.name"></a>node.name</h3><p>节点名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node.name: $&#123;HOSTNAME&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bootstrap-memory-lock"><a href="#bootstrap-memory-lock" class="headerlink" title="bootstrap.memory_lock"></a>bootstrap.memory_lock</h3><p>锁定jvm只用内存,不使用硬盘<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootstrap.memory_lock:true</span><br></pre></td></tr></table></figure></p>
<h3 id="network-host"><a href="#network-host" class="headerlink" title="network.host"></a>network.host</h3><p>默认为127.0.0.1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network.bind_host: 0.0.0.0                #监听所有ip的请求</span><br><span class="line">network.publish_host: _bond1:ipv4_         #发布给集群中其他节点知道的地址</span><br></pre></td></tr></table></figure></p>
<h3 id="discovery-zen-ping-unicast-hosts"><a href="#discovery-zen-ping-unicast-hosts" class="headerlink" title="discovery.zen.ping.unicast.hosts"></a>discovery.zen.ping.unicast.hosts</h3><p>集群中其他节点ip:tcp端口,用来联系集群中其他节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts:</span><br><span class="line">  - 192.168.1.10:9300</span><br><span class="line">  - 192.168.1.11 </span><br><span class="line">  - seeds.mydomain.com</span><br></pre></td></tr></table></figure></p>
<h3 id="discovery-zen-minimum-master-nodes"><a href="#discovery-zen-minimum-master-nodes" class="headerlink" title="discovery.zen.minimum_master_nodes"></a>discovery.zen.minimum_master_nodes</h3><p>最小主节点数目,为了防止脑裂,需要设置发现超过半数的主节点候选者才能组成集群<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">discovery.zen.minimum_master_nodes: 2</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>es</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>es集群启动系统配置检查</title>
    <url>/2017/11/11/es%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="堆大小检查"><a href="#堆大小检查" class="headerlink" title="堆大小检查"></a>堆大小检查</h3><p>./bin/elasticsearch文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ES_HEAP_SIZE=20G</span><br></pre></td></tr></table></figure></p>
<p>./conf/jvm.options<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms2g </span><br><span class="line">-Xmx2g</span><br></pre></td></tr></table></figure></p>
<ul>
<li>把xms(堆初始化大小)和xmx(最大堆大小)设为相等</li>
<li>堆太小oom,堆太大gc停止时间越长</li>
<li>xmx不要超过机器物理内存的50%</li>
<li><p>因为jvm使用压缩对象指针,不要把xmx设超过临界点,临界点一般在靠近32G,正确的日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heap size [1.9gb], compressed ordinary object pointers [true]</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量保持在zero-based compressed oops临界点以下,大多数系统临界点在26G是安全的,有一些系统可以达到30G<br>可以在启动es的时候加上XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode两个jvm参数来检验下是否在临界点之下,会出现如下日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heap address: 0x000000011be00000, size: 27648 MB, zero based Compressed Oops</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这段说明zero-based compressed oops生效了,而不是像这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">heap address: 0x0000000118400000, size: 28672 MB, Compressed Oops with base: 0x00000001183ff000</span><br></pre></td></tr></table></figure></p>
<h3 id="open-files-打开文件数-max-user-processes-最大用户进程数-max-locked-memory-jvm进程锁定到内存"><a href="#open-files-打开文件数-max-user-processes-最大用户进程数-max-locked-memory-jvm进程锁定到内存" class="headerlink" title="open files 打开文件数 /max user processes 最大用户进程数/max locked memory jvm进程锁定到内存"></a>open files 打开文件数 /max user processes 最大用户进程数/max locked memory jvm进程锁定到内存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[esadmin]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size          (kbytes, -d) unlimited</span><br><span class="line">scheduling priority            (-e) 0</span><br><span class="line">file size              (blocks, -f) unlimited</span><br><span class="line">pending signals                (-i) 515100</span><br><span class="line">max locked memory      (kbytes, -l) unlimited</span><br><span class="line">max memory size        (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65535</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues    (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time              (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 65535</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>
<p>/etc/security/limits.conf中配置</p>
<h3 id="检查mmap-count"><a href="#检查mmap-count" class="headerlink" title="检查mmap count"></a>检查mmap count</h3><p>至少262144<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sysctl vm.max_map_count</span><br><span class="line">vm.max_map_count = 262144</span><br></pre></td></tr></table></figure></p>
<p>在/etc/sysctl.conf中修改vm.max_map_count后,运行sysctl vm.max_map_count</p>
<h3 id="检查插件"><a href="#检查插件" class="headerlink" title="检查插件"></a>检查插件</h3><p>没有head<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bin/plugin list</span><br><span class="line">    - analysis-ik</span><br><span class="line">    - delete-by-query</span><br><span class="line">    - mapper-murmur3</span><br><span class="line">    - mapper-size</span><br><span class="line">    - repository-hdfs</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>es</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>es模块配置-集群</title>
    <url>/2017/11/08/es%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE-%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>配置分为static和dynamic两种,<br>static配置在elasticsearch.yml,环境变量,或者在启动节点的命令行中;<br>dynamic可以通过cluster-update-settings api动态更新.</p>
<hr>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>主节点主要功能之一是决定哪个分片分配到哪个节点,什么时候在节点间移动分片来平衡集群</p>
<hr>
<h2 id="分片分配配置"><a href="#分片分配配置" class="headerlink" title="分片分配配置"></a>分片分配配置</h2><h3 id="cluster-routing-allocation-enable-all"><a href="#cluster-routing-allocation-enable-all" class="headerlink" title="cluster.routing.allocation.enable:all"></a>cluster.routing.allocation.enable:all</h3><p>什么样的分片可以被分配</p>
<ul>
<li>all </li>
<li>primaries 仅分配主分片</li>
<li>new_primaries 仅分配新建索引的主分片</li>
<li>none 不允许分配分片<h3 id="cluster-routing-allocation-node-concurrent-recoveries-2"><a href="#cluster-routing-allocation-node-concurrent-recoveries-2" class="headerlink" title="cluster.routing.allocation.node_concurrent_recoveries:2"></a>cluster.routing.allocation.node_concurrent_recoveries:2</h3>一个节点上并发恢复分片的数目<h3 id="cluster-routing-allocation-node-initial-primaries-recoveries-4"><a href="#cluster-routing-allocation-node-initial-primaries-recoveries-4" class="headerlink" title="cluster.routing.allocation.node_initial_primaries_recoveries:4"></a>cluster.routing.allocation.node_initial_primaries_recoveries:4</h3>并发从本地磁盘恢复分片的数目<h3 id="cluster-routing-allocation-same-shard-host-false"><a href="#cluster-routing-allocation-same-shard-host-false" class="headerlink" title="cluster.routing.allocation.same_shard.host:false"></a>cluster.routing.allocation.same_shard.host:false</h3>同一台机器有多个节点的时候,检查同一分片是否重复分配<h3 id="indices-recovery-concurrent-streams-3"><a href="#indices-recovery-concurrent-streams-3" class="headerlink" title="indices.recovery.concurrent_streams:3"></a>indices.recovery.concurrent_streams:3</h3><h3 id="indices-recovery-concurrent-small-file-streams-2"><a href="#indices-recovery-concurrent-small-file-streams-2" class="headerlink" title="indices.recovery.concurrent_small_file_streams:2"></a>indices.recovery.concurrent_small_file_streams:2</h3></li>
</ul>
<hr>
<h2 id="分片平衡配置"><a href="#分片平衡配置" class="headerlink" title="分片平衡配置"></a>分片平衡配置</h2><h3 id="cluster-routing-rebalance-enable-all"><a href="#cluster-routing-rebalance-enable-all" class="headerlink" title="cluster.routing.rebalance.enable:all"></a>cluster.routing.rebalance.enable:all</h3><p>是否平衡分片</p>
<ul>
<li>all</li>
<li>primaries 仅平衡主分片</li>
<li>replicas 仅平衡副本分片</li>
<li>none<h3 id="cluster-routing-allocation-allow-rebalance-indices-all-active"><a href="#cluster-routing-allocation-allow-rebalance-indices-all-active" class="headerlink" title="cluster.routing.allocation.allow_rebalance:indices_all_active"></a>cluster.routing.allocation.allow_rebalance:indices_all_active</h3>什么时候允许平衡</li>
<li>always </li>
<li>indices_primaries_active 当集群中所有的主分片都分配好了</li>
<li>indices_all_active 当集群中所有主分片和副本分片都分配好了<h3 id="cluster-routing-allocation-cluster-concurrent-rebalance-2"><a href="#cluster-routing-allocation-cluster-concurrent-rebalance-2" class="headerlink" title="cluster.routing.allocation.cluster_concurrent_rebalance:2"></a>cluster.routing.allocation.cluster_concurrent_rebalance:2</h3>集群允许并发平衡分片的数目</li>
</ul>
<hr>
<h2 id="分片会被放在哪儿"><a href="#分片会被放在哪儿" class="headerlink" title="分片会被放在哪儿?"></a>分片会被放在哪儿?</h2><p>不管平衡算法如何,forced awareness或者allocation filtering的优先级更高</p>
<h3 id="cluster-routing-allocation-balance-shard-0-45f"><a href="#cluster-routing-allocation-balance-shard-0-45f" class="headerlink" title="cluster.routing.allocation.balance.shard:0.45f"></a>cluster.routing.allocation.balance.shard:0.45f</h3><p>单个节点上分片分配的权重</p>
<h3 id="cluster-routing-allocation-balance-index-0-55f"><a href="#cluster-routing-allocation-balance-index-0-55f" class="headerlink" title="cluster.routing.allocation.balance.index:0.55f"></a>cluster.routing.allocation.balance.index:0.55f</h3><p>单个节点每个索引分片数目的权重</p>
<h3 id="cluster-routing-allocation-balance-threshold-1-0f"><a href="#cluster-routing-allocation-balance-threshold-1-0f" class="headerlink" title="cluster.routing.allocation.balance.threshold:1.0f"></a>cluster.routing.allocation.balance.threshold:1.0f</h3><p>平衡门槛,值越高越不积极去平衡分片</p>
<hr>
<h2 id="基于磁盘的分片分配"><a href="#基于磁盘的分片分配" class="headerlink" title="基于磁盘的分片分配"></a>基于磁盘的分片分配</h2><h3 id="cluster-routing-allocation-disk-threshold-enabled-true"><a href="#cluster-routing-allocation-disk-threshold-enabled-true" class="headerlink" title="cluster.routing.allocation.disk.threshold_enabled:true"></a>cluster.routing.allocation.disk.threshold_enabled:true</h3><p>是否开启磁盘分配</p>
<h3 id="cluster-routing-allocation-disk-watermark-low-85"><a href="#cluster-routing-allocation-disk-watermark-low-85" class="headerlink" title="cluster.routing.allocation.disk.watermark.low:85%"></a>cluster.routing.allocation.disk.watermark.low:85%</h3><p>磁盘检查低水位线,一旦磁盘使用率超过这个水位线,es将不会给该节点分配新的分片,可以设置百分比也可以设成绝对数值</p>
<h3 id="cluster-routing-allocation-disk-watermark-high-90"><a href="#cluster-routing-allocation-disk-watermark-high-90" class="headerlink" title="cluster.routing.allocation.disk.watermark.high:90%"></a>cluster.routing.allocation.disk.watermark.high:90%</h3><p>磁盘检查高水位线,一旦结果超过这个水位线es会尝试把该节点上的分片重新分配到其他节点</p>
<h3 id="cluster-info-update-interval-30s"><a href="#cluster-info-update-interval-30s" class="headerlink" title="cluster.info.update.interval:30s"></a>cluster.info.update.interval:30s</h3><p>磁盘检查时间间隔</p>
<h3 id="cluster-routing-allocation-disk-include-relocations-true"><a href="#cluster-routing-allocation-disk-include-relocations-true" class="headerlink" title="cluster.routing.allocation.disk.include_relocations:true"></a>cluster.routing.allocation.disk.include_relocations:true</h3><p>当计算磁盘使用率的时候是否把正在重新分配的分片考虑进来</p>
<hr>
<h2 id="分片分配感应"><a href="#分片分配感应" class="headerlink" title="分片分配感应"></a>分片分配感应</h2><h3 id="cluster-routing-allocation-awareness-force-zone-values-zone1-zone2"><a href="#cluster-routing-allocation-awareness-force-zone-values-zone1-zone2" class="headerlink" title="cluster.routing.allocation.awareness.force.zone.values: zone1,zone2"></a>cluster.routing.allocation.awareness.force.zone.values: zone1,zone2</h3><p>正常的感应,如果一个zone联系不上其他zone,同一分片还是会分配到同一个zone上;配置了这个参数后,同一主分片和副本分片不允许分配到同一zone上</p>
<h3 id="cluster-routing-allocation-awareness-attributes-rack-id-zone"><a href="#cluster-routing-allocation-awareness-attributes-rack-id-zone" class="headerlink" title="cluster.routing.allocation.awareness.attributes: rack_id,zone"></a>cluster.routing.allocation.awareness.attributes: rack_id,zone</h3><p>启动集群时,指定rack_id,当使用感应属性时,没有该属性的节点将不会被分配分片</p>
<blockquote>
<p>./bin/elasticsearch –node.rack_id rack_one</p>
</blockquote>
<p>感应属性,可设多个值,逗号分隔,执行search或者get操作时,会优先搜索感应群组中的分片,这样通常会更快;当有多个机架时,es会移动分片来保证同一机架内不会存在同一索引的同一主副分片;</p>
<hr>
<h2 id="分片过滤"><a href="#分片过滤" class="headerlink" title="分片过滤"></a>分片过滤</h2><h3 id="cluster-routing-allocation-include-attribute"><a href="#cluster-routing-allocation-include-attribute" class="headerlink" title="cluster.routing.allocation.include.{attribute}"></a>cluster.routing.allocation.include.{attribute}</h3><p>分配索引到满足条件的节点(逗号分隔,至少满足一个)</p>
<h3 id="cluster-routing-allocation-require-attribute"><a href="#cluster-routing-allocation-require-attribute" class="headerlink" title="cluster.routing.allocation.require.{attribute}"></a>cluster.routing.allocation.require.{attribute}</h3><p>分配索引到满足条件的节点(逗号分隔,全部满足)</p>
<h3 id="cluster-routing-allocation-exclude-attribute"><a href="#cluster-routing-allocation-exclude-attribute" class="headerlink" title="cluster.routing.allocation.exclude.{attribute}"></a>cluster.routing.allocation.exclude.{attribute}</h3><p>分配索引到不满足条件的节点</p>
<h3 id="attribute的取值-支持通配符"><a href="#attribute的取值-支持通配符" class="headerlink" title="attribute的取值,支持通配符"></a>attribute的取值,支持通配符</h3><ul>
<li>_name 节点名</li>
<li>_ip 节点ip</li>
<li>_host 节点主机名<h2 id="其他集群配置"><a href="#其他集群配置" class="headerlink" title="其他集群配置"></a>其他集群配置</h2><h3 id="cluster-blocks-read-only-false"><a href="#cluster-blocks-read-only-false" class="headerlink" title="cluster.blocks.read_only:false"></a>cluster.blocks.read_only:false</h3>整个集群只可读,不能创建删除索引<h3 id="logger开头的配置"><a href="#logger开头的配置" class="headerlink" title="logger开头的配置"></a>logger开头的配置</h3>用来管理日志,比如logger.indices.recovery</li>
</ul>
]]></content>
      <tags>
        <tag>es</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>es集群滚动重启</title>
    <url>/2017/10/22/es%E9%9B%86%E7%BE%A4%E6%BB%9A%E5%8A%A8%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<h2 id="禁止分片分配"><a href="#禁止分片分配" class="headerlink" title="禁止分片分配"></a>禁止分片分配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT &apos;/_cluster/settings?pretty&apos; -d &apos;&#123;</span><br><span class="line">  &quot;transient&quot;: &#123;</span><br><span class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="关闭单个节点"><a href="#关闭单个节点" class="headerlink" title="关闭单个节点"></a>关闭单个节点</h2><p>关闭节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kill &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="执行维护-升级等操作"><a href="#执行维护-升级等操作" class="headerlink" title="执行维护/升级等操作"></a>执行维护/升级等操作</h2><p>比如替换./plugins下某个文件夹,替换完成后执行./bin/plugin list 查看插件是否正常<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp esadmin@172.18.187.2:~/es-ik/elasticsearch-analysis-ik-1.9.3.zip ./</span><br></pre></td></tr></table></figure></p>
<h2 id="重启节点"><a href="#重启节点" class="headerlink" title="重启节点"></a>重启节点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bin/elasticsearch -d</span><br></pre></td></tr></table></figure>
<h2 id="打开自动分配"><a href="#打开自动分配" class="headerlink" title="打开自动分配"></a>打开自动分配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT &apos;/_cluster/settings?pretty&apos; -d &apos;&#123;</span><br><span class="line">  &quot;transient&quot;: &#123;</span><br><span class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="检查集群是否恢复完成"><a href="#检查集群是否恢复完成" class="headerlink" title="检查集群是否恢复完成"></a>检查集群是否恢复完成</h2><p>active_shards_percent_as_number进度是100,负载中的分片relocating_shards,正在被初始化分片initializing_shards及为被分配的分片unassigned_shards等均为0时表示恢复完成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET &apos;/_cluster/health?pretty&apos;</span><br></pre></td></tr></table></figure></p>
<p>files_percent,bytes_percent,translog_percent进度为100%时恢复完成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET  &apos;/_cat/recovery?v&amp;human&amp;active_only=true&amp;detailed=true&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="重复步骤1-5"><a href="#重复步骤1-5" class="headerlink" title="重复步骤1-5"></a>重复步骤1-5</h2><h2 id="注意-检查allocation设置"><a href="#注意-检查allocation设置" class="headerlink" title="注意:检查allocation设置"></a>注意:检查allocation设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET  &apos;/_cluster/settings?pretty&amp;filter_path=**.enable&apos;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>es</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo blog</title>
    <url>/2017/05/22/blog/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>$ npm install hexo-cli -g</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p>$ hexo init blog<br>  $ cd blog</p>
</blockquote>
<h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><blockquote>
<p>$ npm i</p>
</blockquote>
<h3 id="修改配置文件-config-yml"><a href="#修改配置文件-config-yml" class="headerlink" title="修改配置文件_config.yml"></a>修改配置文件_config.yml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo</span><br><span class="line">  </span><br><span class="line"># 自定义网站标题,作者,语言(跟主题有关),我这边主题支持zh-Hans简体中文</span><br><span class="line">title: AlreadyGo</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: Hui Zhou</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line">## 自定义url</span><br><span class="line">url: http://alreadygo.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory source为源码目录,public为生成物目录</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line">  </span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &apos;&apos;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## https://github.com/iissnan/hexo-theme-next</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">### npm i hexo-deployer-git --save</span><br><span class="line">#### 修改自定义部署git仓库及分支</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/AlreadyGo/alreadyGo.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="生成static文件"><a href="#生成static文件" class="headerlink" title="生成static文件"></a>生成static文件</h3><blockquote>
<p>$ hexo generate</p>
</blockquote>
<h3 id="删除static文件"><a href="#删除static文件" class="headerlink" title="删除static文件"></a>删除static文件</h3><blockquote>
<p>$ hexo clean </p>
</blockquote>
<h3 id="在本地运行"><a href="#在本地运行" class="headerlink" title="在本地运行"></a>在本地运行</h3><blockquote>
<p>$ hexo server</p>
</blockquote>
<h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><blockquote>
<p>$ hexo deploy</p>
</blockquote>
<h3 id="常见插件安装"><a href="#常见插件安装" class="headerlink" title="常见插件安装"></a>常见插件安装</h3><p><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>这边安装了几个:</p>
<blockquote>
<p>$ npm i hexo-deployer-git –save  //git部署<br>  $ npm i hexo-wordcount –save //post字数统计<br>  $ npm i hexo-generator-searchd –save //本地搜索</p>
</blockquote>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>shaowsocks</title>
    <url>/2017/03/21/shaowsocks/</url>
    <content><![CDATA[<p><img src="https://shadowsocks.be/usr/uploads/shadowsocks.png" alt="Shadowsocks"></p>
<h3 id="本脚本适用环境"><a href="#本脚本适用环境" class="headerlink" title="本脚本适用环境"></a>本脚本适用环境</h3><h4 id="系统支持：CentOS，Debian，Ubuntu"><a href="#系统支持：CentOS，Debian，Ubuntu" class="headerlink" title="系统支持：CentOS，Debian，Ubuntu"></a>系统支持：CentOS，Debian，Ubuntu</h4><h4 id="内存要求：≥128M"><a href="#内存要求：≥128M" class="headerlink" title="内存要求：≥128M"></a>内存要求：≥128M</h4><h3 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h3><h4 id="一键安装-ShadowsocksR-服务端。"><a href="#一键安装-ShadowsocksR-服务端。" class="headerlink" title="一键安装 ShadowsocksR 服务端。"></a>一键安装 ShadowsocksR 服务端。</h4><p>请下载与之配套的客户端程序来连接。<br>（以下客户端只有 <a href="https://github.com/breakwa11/shadowsocks-csharp/releases" target="_blank" rel="noopener">Windows 客户端</a>和 <a href="https://github.com/breakwa11/shadowsocks-rss/wiki/Python-client" target="_blank" rel="noopener">Python 版客户端</a>可以使用 SSR 新特性，其他原版客户端只能以兼容的方式连接 SSR 服务器）</p>
<h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><h5 id="服务器端口：自己设定（如不设定，默认为-8989）"><a href="#服务器端口：自己设定（如不设定，默认为-8989）" class="headerlink" title="服务器端口：自己设定（如不设定，默认为 8989）"></a>服务器端口：自己设定（如不设定，默认为 8989）</h5><h5 id="客户端端口：1080"><a href="#客户端端口：1080" class="headerlink" title="客户端端口：1080"></a>客户端端口：1080</h5><h5 id="密码：自己设定（如不设定，默认为teddysun-com）"><a href="#密码：自己设定（如不设定，默认为teddysun-com）" class="headerlink" title="密码：自己设定（如不设定，默认为teddysun.com）"></a>密码：自己设定（如不设定，默认为teddysun.com）</h5><h5 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h5><ul>
<li><a href="https://github.com/breakwa11/shadowsocks-csharp/releases" target="_blank" rel="noopener">windows</a> </li>
<li><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help" target="_blank" rel="noopener">mac os</a></li>
<li><a href="https://github.com/librehat/shadowsocks-qt5&quot;&gt;Linux" target="_blank" rel="noopener">linux</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks-android" target="_blank" rel="noopener">android</a></li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="使用root用户登录，运行以下命令"><a href="#使用root用户登录，运行以下命令" class="headerlink" title="使用root用户登录，运行以下命令"></a>使用root用户登录，运行以下命令</h5><blockquote>
<p><code>wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh
chmod +x shadowsocksR.sh
./shadowsocksR.sh 2&amp;gt;&amp;amp;1 | tee shadowsocksR.log</code></p>
</blockquote>
<h5 id="安装完成后，脚本提示如下"><a href="#安装完成后，脚本提示如下" class="headerlink" title="安装完成后，脚本提示如下"></a>安装完成后，脚本提示如下</h5><blockquote>
<p><code>Congratulations, 
    ShadowsocksR install completed!
    Server IP:your_server_ip
    Server Port:your_server_port
    Password:your_password
    Local IP:127.0.0.1
    Local Port:1080
    Protocol:origin
    obfs:plain
    Encryption Method:aes-256-cfb
    Welcome to visit:https://shadowsocks.be/9.html
    If you want to change protocol &amp;amp; obfs, reference URL:
    https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup
    Enjoy it!</code></p>
</blockquote>
<h4 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h4><p>使用 root 用户登录，运行以下命令：</p>
<blockquote>
<p>./shadowsocksR.sh uninstall</p>
</blockquote>
<h4 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h4><blockquote>
<p>/etc/init.d/shadowsocks status</p>
</blockquote>
<p>可以查看 ShadowsocksR 进程是否已经启动。<br>本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。</p>
<h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><ol>
<li>启动：/etc/init.d/shadowsocks start</li>
<li>停止：/etc/init.d/shadowsocks stop</li>
<li>重启：/etc/init.d/shadowsocks restart</li>
<li>状态：/etc/init.d/shadowsocks status</li>
</ol>
<h4 id="配置文件路径：-etc-shadowsocks-json"><a href="#配置文件路径：-etc-shadowsocks-json" class="headerlink" title="配置文件路径：/etc/shadowsocks.json"></a>配置文件路径：/etc/shadowsocks.json</h4><h4 id="日志文件路径：-var-log-shadowsocks-log"><a href="#日志文件路径：-var-log-shadowsocks-log" class="headerlink" title="日志文件路径：/var/log/shadowsocks.log"></a>日志文件路径：/var/log/shadowsocks.log</h4><h4 id="代码安装目录：-usr-local-shadowsocks"><a href="#代码安装目录：-usr-local-shadowsocks" class="headerlink" title="代码安装目录：/usr/local/shadowsocks"></a>代码安装目录：/usr/local/shadowsocks</h4><h4 id="多用户配置-sample："><a href="#多用户配置-sample：" class="headerlink" title="多用户配置 sample："></a>多用户配置 sample：</h4><blockquote>
<p><code>{
&quot;server&quot;:&quot;0.0.0.0&quot;,
&quot;server_ipv6&quot;: &quot;[::]&quot;,
&quot;local_address&quot;:&quot;127.0.0.1&quot;,
&quot;local_port&quot;:1080,
&quot;port_password&quot;:{
    &quot;8989&quot;:&quot;password1&quot;,
    &quot;8990&quot;:&quot;password2&quot;，
    &quot;8991&quot;:&quot;password3&quot;
},
&quot;timeout&quot;:300,
&quot;method&quot;:&quot;aes-256-cfb&quot;,
&quot;protocol&quot;: &quot;origin&quot;,
&quot;protocol_param&quot;: &quot;&quot;,
&quot;obfs&quot;: &quot;plain&quot;,
&quot;obfs_param&quot;: &quot;&quot;,
&quot;redirect&quot;: &quot;&quot;,
&quot;dns_ipv6&quot;: false,
&quot;fast_open&quot;: false,
&quot;workers&quot;: 1
}</code></p>
</blockquote>
<h4 id="如果你想修改配置文件，请参考："><a href="#如果你想修改配置文件，请参考：" class="headerlink" title="如果你想修改配置文件，请参考："></a>如果你想修改配置文件，请参考：</h4><p><a href="https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup" target="_blank" rel="noopener">https://github.com/breakwa11/shadowsocks-rss/wiki/Server-Setup</a></p>
<p><a href="https://github.com/breakwa11/shadowsocks-rss" target="_blank" rel="noopener">参考链接 https://github.com/breakwa11/shadowsocks-rss</a></p>
]]></content>
      <tags>
        <tag>shadowsocks</tag>
        <tag>breakwall</tag>
      </tags>
  </entry>
  <entry>
    <title>设置npm代理</title>
    <url>/2017/01/22/%E8%AE%BE%E7%BD%AEnpm%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><h4 id="by-config-command"><a href="#by-config-command" class="headerlink" title="by config command"></a>by config command</h4><blockquote>
<p>npm config set registry <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a><br>    npm info underscore （如果上面配置正确这个命令会有字符串response）</p>
</blockquote>
<h4 id="命令行指定"><a href="#命令行指定" class="headerlink" title="命令行指定"></a>命令行指定</h4><blockquote>
<p>npm –registry <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a> info underscore</p>
</blockquote>
<h4 id="编辑-npmrc-加入下面内容"><a href="#编辑-npmrc-加入下面内容" class="headerlink" title="编辑 ~/.npmrc 加入下面内容"></a>编辑 ~/.npmrc 加入下面内容</h4><blockquote>
<p>registry = <a href="http://registry.cnpmjs.org" target="_blank" rel="noopener">http://registry.cnpmjs.org</a></p>
</blockquote>
<h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><blockquote>
<p>npm config set proxy <a href="http://server:port" target="_blank" rel="noopener">http://server:port</a><br>  npm config set https-proxy <a href="http://server:port" target="_blank" rel="noopener">http://server:port</a></p>
</blockquote>
<h4 id="如果需要认证的话可以这样设置："><a href="#如果需要认证的话可以这样设置：" class="headerlink" title="如果需要认证的话可以这样设置："></a>如果需要认证的话可以这样设置：</h4><blockquote>
<p>npm config set proxy <a href="http://username:password@server:port" target="_blank" rel="noopener">http://username:password@server:port</a><br>npm confit set https-proxy <a href="http://username:password@server:port" target="_blank" rel="noopener">http://username:password@server:port</a></p>
</blockquote>
<h4 id="如果代理不支持https的话需要修改npm存放package的网站地址。"><a href="#如果代理不支持https的话需要修改npm存放package的网站地址。" class="headerlink" title="如果代理不支持https的话需要修改npm存放package的网站地址。"></a>如果代理不支持https的话需要修改npm存放package的网站地址。</h4><blockquote>
<p>npm config set registry “<a href="http://registry.npmjs.org/&quot;" target="_blank" rel="noopener">http://registry.npmjs.org/&quot;</a></p>
</blockquote>
<h3 id="使用nrm快速切换npm源"><a href="#使用nrm快速切换npm源" class="headerlink" title="使用nrm快速切换npm源"></a>使用nrm快速切换npm源</h3><blockquote>
<p>nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换</p>
</blockquote>
<h4 id="列表项目"><a href="#列表项目" class="headerlink" title="列表项目"></a>列表项目</h4><ul>
<li>npm</li>
<li>cnpm</li>
<li>strongloop</li>
<li>enropean</li>
<li>australia</li>
<li>nodejitsu</li>
<li>taobao</li>
</ul>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><blockquote>
<p>sudo npm install -g nrm</p>
</blockquote>
<h4 id="列出可用的源："><a href="#列出可用的源：" class="headerlink" title="列出可用的源："></a>列出可用的源：</h4><blockquote>
<p>~  nrm ls<br>  npm —- <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a><br>  cnpm — <a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a><br>  taobao - <a href="http://registry.npm.taobao.org/" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a><br>  eu —– <a href="http://registry.npmjs.eu/" target="_blank" rel="noopener">http://registry.npmjs.eu/</a><br>  au —– <a href="http://registry.npmjs.org.au/" target="_blank" rel="noopener">http://registry.npmjs.org.au/</a><br>  sl —– <a href="http://npm.strongloop.com/" target="_blank" rel="noopener">http://npm.strongloop.com/</a><br>  nj —– <a href="https://registry.nodejitsu.com/" target="_blank" rel="noopener">https://registry.nodejitsu.com/</a><br>  pt —– <a href="http://registry.npmjs.pt/" target="_blank" rel="noopener">http://registry.npmjs.pt/</a></p>
</blockquote>
<h4 id="切换："><a href="#切换：" class="headerlink" title="切换："></a>切换：</h4><blockquote>
<p>~  nrm use taobao<br>   Registry has been set to: <a href="http://registry.npm.taobao.org/" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a></p>
</blockquote>
<h4 id="增加源："><a href="#增加源：" class="headerlink" title="增加源："></a>增加源：</h4><blockquote>
<p>nrm add <registry> <url> [home]</url></registry></p>
</blockquote>
<h4 id="删除源："><a href="#删除源：" class="headerlink" title="删除源："></a>删除源：</h4><blockquote>
<p>nrm del <registry></registry></p>
</blockquote>
<h4 id="测试速度："><a href="#测试速度：" class="headerlink" title="测试速度："></a>测试速度：</h4><blockquote>
<p>nrm test</p>
</blockquote>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装mysql常见问题</title>
    <url>/2017/01/21/linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.无法远程连接mysql  1130</p>
<p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser‘@’%’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p>
<p>2.服务端中文乱码</p>
<p>[mysqld]</p>
<p>character_set_server=utf8</p>
<p>service mysql restart</p>
<p>此时,</p>
<p><pre>mysql -u root -p</pre><br>status</p>
<p>会有类似的结果:Server characterset: utf8</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
